#include <iostream>
#include "DictTree.h"
#include "MyFile.h"
//create a branch of documents which have the same size "str"
void DictTree::create(long length ,char *name, char *path, node *root){ 
  //printf("call create");
    int in = 0;\
    char str[20];\
    sprintf(str, "%ld", length);\
    int len = strlen(str);\
    node *p = root;
    
    for (int i = 0; i < len; i++){
        int in = str[i] - '0';
    
        if (p->next[in] == NULL){
           if((p->next[in] = (node *)malloc(sizeof(node))) == NULL){
               memset(p->next[in], '\0', sizeof(node));
            fprintf(stderr,"cant reserve memory!");
            abort(); 
           } 
           for (int i = 0; i < 10; i++) {
             p->next[in]->next[i] = NULL;
           }
           p->next[in]->docu = NULL;
        }
        p = p->next[in];
       
        in = 0;
    }
 
    if((p->docu = (document *)malloc(sizeof(document))) == NULL ) {
        memset(p->docu, '\0', sizeof(document));
            fprintf(stderr,"cant reserve memory!");
            abort(); 
           } 
    p->docu->next = NULL;
    //printf("  create -> %p ->next%p:", p->docu,p->docu->next);
    strcpy(p->docu->fpath, path);
    strcpy(p->docu->fname, name);
   
  // printf("finish create");
}

//check if a branch of documents with size length exists 
bool DictTree::query(long length, node *root){
     //printf("call create");
    int in = 0;
    char str[20];
    sprintf(str, "%ld", length);
    int len = strlen(str);
    node *p = root;
    for (int i = 0; i < len; i++){
        in = str[i] - '0';
        if (p->next[in] == NULL) return 0;
        else p = p->next[in];
    }
    if (p->next[10] != NULL) return 1;
    else return 0;
}

//go through the branch of size length
int DictTree::ListDocu(long length, char *path, char *name, node *root){
   // FILE *fp1;
  //  if ((fp1 = fopen("//home//desktop//result##**.out","a")) != NULL) printf("success open .out\n");
       // else printf("open .out fail");
    //printf("call create");
    node *p = root; 
    document *q;

    char str[20];
    sprintf(str, "%ld", length);
    int len = strlen(str);
    int in;
    for (int i = 0; i < len; i++){
      in = str[i] - '0';
      p = p->next[in];
    }
    q = p->docu;
    std::string path1 = path;
    path1 += '/';
    path1 += name;
    
    std::string path2 = q->fpath;
    path2 += '/';
    path2 += q->fname;
   
    if (docuCheck(q, path1)) return 1;
    else return 0;
  
  //int opt = 1;//MyFile::Compare(path1, path2);
       // if (opt != 2) {
                //if (opt){
               // fprintf(fp1, "%s\tis identical to\t%s\n",path2.c_str(),path1.c_str());
              //  printf("\n\n%s\tis identical to\t%s\n\n",path2.c_str(),path1.c_str());
               // fclose(fp1);
               // return 1;//exit(0);
               // } 
              //  q = q->next;
            
       // } else {
        //   fprintf(stderr,"fail to open file %s\n", name);
           // if (fp1 != NULL) fclose(fp1);
         //   return 0;//exit(1);
       // }
        //q = q->next;
        return 1;
  
    
}

void DictTree::insertf(long length, char *_name, char *_path, node *root) {
   //printf("call insert: %-20s%ld\n", _name,length);
    
    // printf("call create");
    int in = 0;
    char str[20];
    sprintf(str, "%ld", length);
    int len = strlen(str);
    node *p = root;

    p = root; 
    document *q;
    //get to the node of size str
    for (int i = 0; i < len ; i++){
      in = str[i] - '0';
      p = p->next[in];
    }
    //get to the end of docu list of size ptr
    q = p->docu;
    while (q->next !=NULL) {
        q = q->next;
    }    
    //insert document
    if((q->next = (document *)malloc(sizeof(document))) == NULL) {
        memset(q->next, '\0', sizeof(document));
            fprintf(stderr,"cant reserve memory!");
            abort(); 
           } 

    
    q = q->next;
    q-> next= NULL;
           //printf(" insert -> %p ->next: %p",q,q->next);
    strcpy(q->fpath, _path);
    strcpy(q->fname, _name);
           //printf("finish insert");
    
}
void DictTree::freedocu(document *ptr) {
  //  printf("call free docu %s/%s ->: %p\n",ptr->fpath, ptr->fname, ptr->next);
    if (ptr->next != NULL) {
       
        freedocu(ptr->next);
    } //else 
    //if (ptr != NULL)
     free(ptr);
  //  printf("return from free docu \n");
   
}
void DictTree::freetree(node *ptr){
 // printf("call free tree\n");
    if (ptr->docu != NULL) {
        //printf("call free ptr->docu\n");
        freedocu(ptr->docu);
    }
  
    for (int i = 0; i < 10;i++){
        if (ptr->next[i] != NULL) {
            //printf("%d",i);
            freetree(ptr->next[i]);
        } 
    }
   free(ptr);
  // printf("return from free node\n");
   
}
int DictTree::docuCheck(document *q, std::string path1) {
    printf("call docuCheck");
    std::string path2 = q->fpath;
    path2 += '/';
    path2 += q->fname;

    if (MyFile::Compare(path1, path2)) {
        std::cout << path1 << "\t" << "is identical to" << "\t" << path2 << std::endl;
        return 1;
    } else 
        if (q->next != NULL) 
            docuCheck(q->next, path1);
    printf("return docuCheck");
    return 0;
}
